<?php
require_once(dirname(__FILE__) . '/abstract_writer.php');

class export_xls extends abstract_writer {
  /**
   * MicrosoftXML Header for Excel
   * @var string
   */

  const HEADER = "<?xml version=\"1.0\" encoding=\"%s\"?\>\n
  <Workbook
    xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"
    xmlns:x=\"urn:schemas-microsoft-com:office:excel\"
    xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"
    xmlns:html=\"http://www.w3.org/TR/REC-html40\">";

  /**
   * MicrosoftXML Footer for Excel
   * @var string
   */
  const FOOTER = "</Workbook>";

  /**
   * Worksheet & Data
   * @var array
   */
  private $worksheetData;

  /**
   * Output string
   * @var string
   */
  private $output;

  /**
   * Encoding to be used
   * @var string
   */
  private $encoding;
  private $docProp = array(
    'Author' => 'BasicExcel',
    'Company' => 'OmniHost.co.nz',
    'Keywords' => '',
    'Version' => '1.0.0',
    'Title' => '',
    'Subject' => '',
    'Comments' => ''
  );

  /**
   * Constructor
   *
   * Instanciates the class allowing a user-defined encoding.
   *
   * @param string $encoding Charset encoding to be used
   */
  public function __construct($sEncoding = 'UTF-8') {
    $this->encoding = $sEncoding;
    $this->output = '';
  }

  public function setProp($prop, $value) {
    if (isset($this->docProp[$prop])) {
      $this->docProp[$prop] = $value;
    }
    return $this;
  }

  public function setProps($props) {
    foreach ($props as $key => $value) {
      $this->setProp($key, $value);
    }
    return $this;
  }

  /**
   * Add a worksheet
   *
   * Creates a new worksheet and adds the given data to it.
   * @param string $title Title of worksheet
   * @param array $data 2-dimensional array of data
   */
  public function addWorksheet($title, $data) {
    $this->worksheetData[] = array(
      'title' => $this->getWorksheetTitle($title),
      'data' => $data
    );
    return $this;
  }

  protected function headers($filename) {
    if (preg_match('/\.xls$/', $filename)) {
      header("Content-Type: application/vnd.ms-excel; charset=" . $this->encoding);
      header("Content-Disposition: inline; filename=\"" . $filename . "\"");
    } else {
      header("Content-Type: application/xml; charset=" . $this->encoding);
      header("Content-Disposition: attachment; filename=\"" . $filename . "\"");
    }
    echo $this->output;
  }

  protected function write($filename) {
    if (!preg_match('/\.(xml|xls|xlsx)$/', $filename)) {
      throw new Exception('Filename mimetype must be .xml or .xls');
    }
    $filename = $this->filename($filename);
    $this->generateWorkbook();

    if (@fwrite($this->handle, $this->output) === FALSE) {
      throw new Exception(sprintf("Error writing to file %s", $filename));
    }

    if (!fclose($this->handle)) {
      throw new Exception("Could not close handle");
    }
  }

  public function fromCsv($file, $delimiter = ',') {
    $tmpArr = array();
    for ($i = 0; $i < count($file); $i++) {
      $arr = str_getcsv($file[$i], $delimiter);
      $tmpArr[] = $arr;
    }
    $this->addWorksheet("sheet 1", $tmpArr);

    return $this;
  }

  public function fromArray($array, $sheetName = 'sheet 1') {

    $c = current($array);
    if (is_array($c)) {
      foreach ($array as $key => $row) {
        if (is_numeric($key)) {
          $key = 'Sheet ' . ($key + 1);
        }
        $this->addWorksheet($key, $row);
      }
    } else {
      $this->addWorksheet($sheetName, $array);
    }
    return $this;
  }

  /**
   * Get workbook output
   * @return string Output generated by the class
   */
  public function getWorkbook() {
    $this->generateWorkbook();
    return $this->output;
  }

  /**
   * Worksheet title correction
   * @param string $title Desired worksheet title
   * @return string Corrected worksheet title
   */
  private function getWorksheetTitle($title) {
    $title = preg_replace("/[\\\|:|\/|\?|\*|\[|\]]/", "", $title);
    return substr($title, 0, 31);
  }

  /**
   *
   */
  private function generateWorkbook() {
    $this->output .= stripslashes(sprintf(self::HEADER, $this->encoding)) . "\n";
    $this->output .= '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">';
    $this->output .= '
            <Generator><![CDATA[BasicExcel by papaya]]></Generator>';
    foreach ($this->docProp as $propname => $propval) {
      $this->output .= '<' . $propname . '>' . $propval . '</' . $propname . '>';
    }
    $this->output .= '<Created>' . gmdate("Y-m-d\TH:i:s\Z") . '</Created>';

    $this->output .= '</DocumentProperties>';
    foreach ($this->worksheetData as $item) {
      $this->generateWorksheet($item);
    }
    $this->output .= self::FOOTER;
  }

  /**
   * Generate the Worksheet
   * @param array $item Worksheet data
   */
  private function generateWorksheet($item) {
    $this->output .= sprintf("<Worksheet ss:Name=\"%s\">\n    <Table>\n", $item['title']);
    if (count($item['data'])) {
      $item['data'] = array_slice($item['data'], 0, 65536);
    }

    foreach ($item['data'] as $k => $v) {
      $this->generateRow($v);
    }
    $this->output .= "</Table>\n</Worksheet>\n";
  }

  /**
   * Generate the single row
   * @param array Item with row data
   */
  private function generateRow($item) {
    $this->output .= "<Row>\n";
    foreach ($item as $k => $v) {
      $this->generateCell($v);
    }
    $this->output .= "</Row>\n";
  }

  /**
   * Generate the single cell
   * @param string $item Cell data
   */
  private function generateCell($item, $type = 'String') {
    if (is_numeric($item)) {
      $type = 'Number';
      if ($item{0} == '0' && strlen($item) > 1 && $item{1} != '.') {
        $type = 'String';
      }
    }

    $item = str_replace('&#039;', '&apos;', htmlspecialchars($item, ENT_QUOTES));
    $this->output .= sprintf("<Cell><Data ss:Type=\"%s\">%s</Data></Cell>\n", $type, $item);
  }

  /**
   * Deconstructor
   * Resets the main variables/objects
   */
  public function __destruct() {
    unset($this->worksheetData);
    unset($this->output);
  }

}